<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="GOOD webCode style: https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0008&#x2F; Auto grader OK Guidehttps:&#x2F;&#x2F;cs61a.org&#x2F;articles&#x2F;using-ok&#x2F; VocabCommerce The high productivity of computer science is only possible because the disc">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61A Textbook note">
<meta property="og:url" content="http://example.com/2025/12/22/61A_textbook_note/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="GOOD webCode style: https:&#x2F;&#x2F;peps.python.org&#x2F;pep-0008&#x2F; Auto grader OK Guidehttps:&#x2F;&#x2F;cs61a.org&#x2F;articles&#x2F;using-ok&#x2F; VocabCommerce The high productivity of computer science is only possible because the disc">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-22T06:42:49.297Z">
<meta property="article:modified_time" content="2025-12-22T06:49:49.901Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/12/22/61A_textbook_note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CS61A Textbook note | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/22/61A_textbook_note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS61A Textbook note
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-12-22 14:42:49 / Modified: 14:49:49" itemprop="dateCreated datePublished" datetime="2025-12-22T14:42:49+08:00">2025-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="GOOD-web"><a href="#GOOD-web" class="headerlink" title="GOOD web"></a>GOOD web</h1><p>Code style: <a target="_blank" rel="noopener" href="https://peps.python.org/pep-0008/">https://peps.python.org/pep-0008/</a></p>
<p>Auto grader OK Guide<a target="_blank" rel="noopener" href="https://cs61a.org/articles/using-ok/">https://cs61a.org/articles/using-ok/</a></p>
<h1 id="Vocab"><a href="#Vocab" class="headerlink" title="Vocab"></a>Vocab</h1><p><strong>Commerce</strong></p>
<p>The high productivity of computer science is only possible because the discipline is built upon an elegant and powerful set of fundamental ideas. All computing begins with representing information, specifying logic to process it, and designing abstractions that manage the complexity of that logic. Mastering these fundamentals will require us to understand precisely how computers interpret computer programs and carry out computational processes.</p>
<p>A language isn’t something you learn so much as something you join. meaning？</p>
<p><strong>conceived</strong></p>
<p>The language was conceived and first implemented by <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Guido_van_Rossum">Guido van Rossum</a> in the late 1980’s</p>
<p>In an interactive Python session, you type some Python <em>code</em> after the <em>prompt</em>, <code>&gt;&gt;&gt;</code>. The Python <em>interpreter</em> reads and executes what you type, <strong>carrying out</strong> your various commands.</p>
<h1 id="C1-Building-Abstractions-with-Functions"><a href="#C1-Building-Abstractions-with-Functions" class="headerlink" title="C1 Building Abstractions with Functions"></a>C1 Building Abstractions with Functions</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><h3 id="1-1-4-First-Example"><a href="#1-1-4-First-Example" class="headerlink" title="1.1.4  First Example"></a>1.1.4  First Example</h3><p><strong>Statements &amp; Expressions</strong>. Python code consists of expressions and statements. Broadly, computer programs consist of instructions to either</p>
<ol>
<li>Compute some value</li>
<li>Carry out some action</li>
</ol>
<p>Statements typically describe actions. When the Python interpreter executes a statement, it carries out the corresponding action. On the other hand, expressions typically describe computations. When Python evaluates an expression, it computes the value of that expression. This chapter introduces several types of statements and expressions.</p>
<p><strong>Functions</strong>. Functions encapsulate logic that manipulates data.</p>
<h2 id="1-2-Elements-of-Programming"><a href="#1-2-Elements-of-Programming" class="headerlink" title="1.2 Elements of Programming"></a>1.2 Elements of Programming</h2><p>Informally, data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. </p>
<h2 id="1-3-Defining-new-function"><a href="#1-3-Defining-new-function" class="headerlink" title="1.3 Defining new function"></a>1.3 Defining new function</h2><h3 id="1-3-1"><a href="#1-3-1" class="headerlink" title="1.3.1"></a>1.3.1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> mul(x, x)</span><br></pre></td></tr></table></figure>

<p>The <code>x</code> in this definition is called a <em><strong>formal parameter</strong></em>, which provides a name for the thing to be multiplied.</p>
<p><strong>How to define a function.</strong> Function definitions consist of a <code>def</code> statement that indicates a <code>&lt;name&gt;</code> and a comma-separated list of named <code>&lt;formal parameters&gt;</code>, then a <code>return</code> statement, called the function body, that specifies the <code>&lt;return expression&gt;</code> of the function, which is an expression to be evaluated whenever the function is applied:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def &lt;name&gt;(&lt;formal parameters&gt;):</span><br><span class="line">    return &lt;return expression&gt;</span><br></pre></td></tr></table></figure>





<p><strong>Function Signatures.</strong> Functions differ in the number of arguments that they are allowed to take. To track these requirements, we draw each function in a way that shows the function name and its formal parameters. The user-defined function <code>square</code> takes only <code>x</code>; providing more or fewer arguments will result in an error. A description of the formal parameters of a function is called the function’s signature.</p>
<h2 id="1-3-2"><a href="#1-3-2" class="headerlink" title="1.3.2"></a>1.3.2</h2><p><strong>Name Evaluation.</strong> A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.</p>
<h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><p>We now turn to the topic of what makes a good function. Fundamentally, the qualities of good functions all reinforce the idea that functions are abstractions.</p>
<ul>
<li>Each function should have exactly one job. That job should be identifiable with a short name and characterizable in a single line of text. Functions that perform multiple jobs in sequence should be divided into multiple functions.</li>
<li><em>Don’t repeat yourself</em> is a central tenet of software engineering. The so-called DRY principle states that multiple fragments of code should not describe redundant logic. Instead, that logic should be implemented once, given a name, and applied multiple times. If you find yourself copying and pasting a block of code, you have probably found an opportunity for functional abstraction.</li>
<li>Functions should be defined generally. Squaring is not in the Python Library precisely because it is a special case of the <code>pow</code> function, which raises numbers to arbitrary powers.</li>
</ul>
<p>These guidelines improve the readability of code, reduce the number of errors, and often minimize the total amount of code written. Decomposing a complex task into concise functions is a skill that takes experience to master. Fortunately, Python provides several features to support your efforts.</p>
<h2 id="1-5-Control"><a href="#1-5-Control" class="headerlink" title="1.5 Control"></a>1.5 Control</h2><p>expressive power of </p>
<h3 id="1-5-1-Statements"><a href="#1-5-1-Statements" class="headerlink" title="1.5.1 Statements"></a>1.5.1 Statements</h3><h3 id="1-5-4"><a href="#1-5-4" class="headerlink" title="1.5.4"></a>1.5.4</h3><p><strong>Boolean contexts</strong>. Python includes several false values, including 0, <code>None</code>, and the <em>boolean</em> value <code>False</code>. </p>
<p><strong>Boolean values</strong>. Python has two boolean values, called <code>True</code> and <code>False</code>. Boolean values represent truth values in logical expressions. The built-in comparison operations, <code>&gt;, &lt;, &gt;=, &lt;=, ==, !=</code>, return these values.</p>
<p><strong>Boolean operators</strong>. Three basic logical operators are also built into Python:</p>
<p>Logical expressions have corresponding evaluation procedures. These procedures exploit the fact that the truth value of a logical expression can sometimes be determined without evaluating all of its subexpressions, a feature called <em>short-circuiting</em>.</p>
<p>To evaluate the expression <code>&lt;left&gt; and &lt;right&gt;</code>:</p>
<ol>
<li>Evaluate the subexpression <code>&lt;left&gt;</code>.</li>
<li>If the result is a false value <code>v</code>, then the expression evaluates to <code>v</code>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression <code>&lt;right&gt;</code>.</li>
</ol>
<p>To evaluate the expression <code>&lt;left&gt; or &lt;right&gt;</code>:</p>
<ol>
<li>Evaluate the subexpression <code>&lt;left&gt;</code>.</li>
<li>If the result is a true value <code>v</code>, then the expression evaluates to <code>v</code>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression <code>&lt;right&gt;</code>.</li>
</ol>
<p>To evaluate the expression <code>not &lt;exp&gt;</code>:</p>
<ol>
<li>Evaluate <code>&lt;exp&gt;</code>; The value is <code>True</code> if the result is a false value, and <code>False</code> otherwise.</li>
</ol>
<p>These values, rules, and operators provide us with a way to combine the results of comparisons. Functions that perform comparisons and return boolean values typically begin with <code>is</code>, not followed by an underscore (e.g., <code>isfinite</code>, <code>isdigit</code>, <code>isinstance</code>, etc.).</p>
<h3 id="1-5-5-Iteration"><a href="#1-5-5-Iteration" class="headerlink" title="1.5.5 Iteration"></a>1.5.5 Iteration</h3><p>while statement while :</p>
<p>indention should be the same</p>
<p>if </p>
<p>elif</p>
<p>else</p>
<h3 id="1-5-6-Testing"><a href="#1-5-6-Testing" class="headerlink" title="1.5.6 Testing"></a>1.5.6 Testing</h3><p>assert function</p>
<p>docstring</p>
<p>first line describe</p>
<p>one blank line</p>
<h2 id="1-6-Higher-Order-Functions"><a href="#1-6-Higher-Order-Functions" class="headerlink" title="1.6 Higher-Order Functions"></a>1.6 Higher-Order Functions</h2><p>Functions that manipulate functions are called higher-order functions. This section shows how higher-order functions can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.</p>
<h3 id="1-6-1-Functions-as-Arguments"><a href="#1-6-1-Functions-as-Arguments" class="headerlink" title="1.6.1  Functions as Arguments"></a>1.6.1  Functions as Arguments</h3><h1 id="Chapter-2-Building-Abstractions-with-Data"><a href="#Chapter-2-Building-Abstractions-with-Data" class="headerlink" title="Chapter 2: Building Abstractions with Data"></a>Chapter 2: Building Abstractions with Data</h1><h2 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1  Introduction"></a>2.1  Introduction</h2><p>We concentrated in Chapter 1 on computational processes and on the role of functions in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic), how to form compound functions through composition and control, and how to create functional abstractions by giving names to processes. We also saw that higher-order functions enhance the power of our language by enabling us to manipulate, and thereby to reason, in terms of general methods of computation. This is much of the essence of programming.</p>
<p><strong>This chapter focuses on data.</strong> The techniques we investigate here will allow us to represent and manipulate information about many different domains. Due to the explosive growth of the Internet, a vast amount of structured information is freely available to all of us online, and computation can be applied to a vast range of different problems. Effective use of built-in and user-defined data types are fundamental to data processing applications.</p>
<h3 id="2-1-1-Native-Data-Types"><a href="#2-1-1-Native-Data-Types" class="headerlink" title="2.1.1  Native Data Types"></a>2.1.1  Native Data Types</h3><h3 id="2-1-1-Native-Data-Types-1"><a href="#2-1-1-Native-Data-Types-1" class="headerlink" title="2.1.1  Native Data Types"></a>2.1.1  Native Data Types</h3><p>Every value in Python has a <em>class</em> that determines what type of value it is. Values that share a class also share behavior. For example, the integers <code>1</code> and <code>2</code> are both instances of the <code>int</code> class. These two values can be treated similarly. For example, they can both be negated or added to another integer. The built-in <code>type</code> function allows us to inspect the class of any value.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(2)</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>The values we have used so far are instances of a small number of <em>native</em> data types that are built into the Python language. Native data types have the following properties:</p>
<ol>
<li>There are expressions that evaluate to values of native types, called <em>literals</em>.</li>
<li>There are built-in functions and operators to manipulate values of native types.</li>
</ol>
<p>The <code>int</code> class is the native data type used to represent integers. Integer literals (sequences of adjacent numerals) evaluate to <code>int</code> values, and mathematical operators manipulate these values.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 12 + 3000000000000000000000000</span><br><span class="line">3000000000000000000000012</span><br></pre></td></tr></table></figure>

<p>Python includes three native numeric types: integers (<code>int</code>), real numbers (<code>float</code>), and complex numbers (<code>complex</code>).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(1.5)</span><br><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(1+1j)</span><br><span class="line">&lt;class &#x27;complex&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Floats.</strong> The name <code>float</code> comes from the way in which real numbers are represented in Python and many other programming languages: a “floating point” representation. While the details of how numbers are represented is not a topic for this text, some high-level differences between <code>int</code> and <code>float</code> objects are important to know. In particular, <code>int</code> objects represent integers exactly, without any approximation or limits on their size. On the other hand, <code>float</code> objects can represent a wide range of fractional numbers, but not all numbers can be represented exactly, and there are minimum and maximum values. Therefore, <code>float</code> values should be treated as approximations to real values. These approximations have only a finite amount of precision. Combining <code>float</code> values can lead to approximation errors; both of the following expressions would evaluate to <code>7</code> if not for approximation.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 7 / 3 * 3</span><br><span class="line">7.0</span><br><span class="line">&gt;&gt;&gt; 1 / 3 * 7 * 3</span><br><span class="line">6.999999999999999</span><br></pre></td></tr></table></figure>

<p>Although <code>int</code> values are combined above, dividing one <code>int</code> by another yields a <code>float</code> value: a truncated finite approximation to the actual ratio of the two integers divided.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(1/3)</span><br><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; 1/3</span><br><span class="line">0.3333333333333333</span><br></pre></td></tr></table></figure>

<p>Problems with this approximation appear when we conduct equality tests.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1/3 == 0.333333333333333312345  # Beware of float approximation</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>These subtle differences between the <code>int</code> and <code>float</code> class have wide-ranging consequences for writing programs, and so they are details that must be memorized by programmers. Fortunately, there are only a handful of native data types, limiting the amount of memorization required to become proficient in a programming language. Moreover, these same details are consistent across many programming languages, enforced by community guidelines such as the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754 floating point standard</a>.</p>
<p><strong>Non-numeric types.</strong> Values can represent many other types of data, such as sounds, images, locations, web addresses, network connections, and more. A few are represented by native data types, such as the <code>bool</code> class for values <code>True</code> and <code>False</code>. The type for most values must be defined by programmers using the means of combination and abstraction that we will develop in this chapter.</p>
<p>The following sections introduce more of Python’s native data types, focusing on the role they play in creating useful data abstractions. For those interested in further details, a chapter on <a target="_blank" rel="noopener" href="http://getpython3.com/diveintopython3/native-datatypes.html">native data types</a> in the online book Dive Into Python 3 gives a pragmatic overview of all Python’s native data types and how to manipulate them, including numerous usage examples and practical tips.</p>
<h2 id="2-2-Data-Abstraction"><a href="#2-2-Data-Abstraction" class="headerlink" title="2.2  Data Abstraction"></a>2.2  Data Abstraction</h2><p>As we consider the wide set of things in the world that we would like to represent in our programs, we find that most of them have compound structure. For example, a geographic position has latitude and longitude coordinates. To represent positions, we would like our programming language to have the capacity to couple together a latitude and longitude to form a pair, a <em>compound data</em> value that our programs can manipulate as a single conceptual unit, but which also has two parts that can be considered individually.</p>
<p><em>data abstraction</em>.</p>
<p>The general technique of isolating the parts of a program that deal with <strong>how data are represented</strong> from the parts that deal with <strong>how data are manipulated</strong> is a powerful design methodology called <em>data abstraction</em>.</p>
<p>Data abstraction is similar in character to functional abstraction. When we create a functional abstraction, the details of how a function is implemented can be suppressed, and the particular function itself can be replaced by any other function with the same overall behavior. In other words, we can make an abstraction that separates the way the function is used from the details of how the function is implemented. Analogously, data abstraction isolates how a compound data value is used from the details of how it is constructed.</p>
<p>The basic idea of data abstraction is to structure programs so that they operate on abstract data. That is, our programs should use data in such a way as to make as few assumptions about the data as possible. At the same time, a concrete data representation is defined as an independent part of the program.</p>
<p>These two parts of a program, the part that operates on abstract data and the part that defines a concrete representation, are connected by a small set of functions that implement abstract data in terms of the concrete representation. To illustrate this technique, we will consider how to design a set of functions for manipulating rational numbers.</p>
<h3 id="2-2-1-Example-Rational-Numbers"><a href="#2-2-1-Example-Rational-Numbers" class="headerlink" title="2.2.1  Example: Rational Numbers"></a>2.2.1  Example: Rational Numbers</h3><p>A rational number is a ratio of integers, and rational numbers constitute an important sub-class of real numbers. A rational number such as <code>1/3</code> or <code>17/29</code> is typically written as:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;numerator&gt;/&lt;denominator&gt;</span><br></pre></td></tr></table></figure>

<p>where both the <code>&lt;numerator&gt;</code> and <code>&lt;denominator&gt;</code> are placeholders for integer values. Both parts are needed to exactly characterize the value of the rational number. Actually dividing integers produces a <code>float</code> approximation, losing the exact precision of integers.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1/3</span><br><span class="line">0.3333333333333333</span><br><span class="line">&gt;&gt;&gt; 1/3 == 0.333333333333333300000  # Dividing integers yields an approximation</span><br><span class="line">True</span><br></pre></td></tr></table></figure>



<p>A rational number is a ratio of integers, and rational numbers constitute an important sub-class of real numbers. A rational number such as <code>1/3</code> or <code>17/29</code> is typically written as:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;numerator&gt;/&lt;denominator&gt;</span><br></pre></td></tr></table></figure>

<p>where both the <code>&lt;numerator&gt;</code> and <code>&lt;denominator&gt;</code> are placeholders for integer values. Both parts are needed to exactly characterize the value of the rational number. Actually dividing integers produces a <code>float</code> approximation, losing the exact precision of integers.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1/3</span><br><span class="line">0.3333333333333333</span><br><span class="line">&gt;&gt;&gt; 1/3 == 0.333333333333333300000  # Dividing integers yields an approximation</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>However, we can create an exact representation for rational numbers by combining together the numerator and denominator.</p>
<p>We know from using functional abstractions that we can start programming productively before we have an implementation of some parts of our program. Let us begin by assuming that we already have a way of constructing a rational number from a numerator and a denominator. We also assume that, given a rational number, we have a way of selecting its numerator and its denominator component. Let us further assume that the constructor and selectors are available as the following three functions:</p>
<ul>
<li><code>rational(n, d)</code> returns the rational number with numerator <code>n</code> and denominator <code>d</code>.</li>
<li><code>numer(x)</code> returns the numerator of the rational number <code>x</code>.</li>
<li><code>denom(x)</code> returns the denominator of the rational number <code>x</code>.</li>
</ul>
<p>We are using here a powerful strategy for designing programs: <em>wishful thinking</em>. We haven’t yet said how a rational number is represented, or how the functions <code>numer</code>, <code>denom</code>, and <code>rational</code> should be implemented. Even so, if we did define these three functions, we could then add, multiply, print, and test equality of rational numbers:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add_rationals(x, y):</span><br><span class="line">        nx, dx = numer(x), denom(x)</span><br><span class="line">        ny, dy = numer(y), denom(y)</span><br><span class="line">        return rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line">&gt;&gt;&gt; def mul_rationals(x, y):</span><br><span class="line">        return rational(numer(x) * numer(y), denom(x) * denom(y))</span><br><span class="line">&gt;&gt;&gt; def print_rational(x):</span><br><span class="line">        print(numer(x), &#x27;/&#x27;, denom(x))</span><br><span class="line">&gt;&gt;&gt; def rationals_are_equal(x, y):</span><br><span class="line">        return numer(x) * denom(y) == numer(y) * denom(x)</span><br></pre></td></tr></table></figure>

<p>Now we have the operations on rational numbers defined in terms of the selector functions <code>numer</code> and <code>denom</code>, and the constructor function <code>rational</code>, but we haven’t yet defined these functions. What we need is some way to glue together a numerator and a denominator into a compound value.</p>
<h3 id="2-2-2-Pairs"><a href="#2-2-2-Pairs" class="headerlink" title="2.2.2  Pairs"></a>2.2.2  Pairs</h3><p>preceding expression.</p>
<p>To enable us to implement the concrete level of our data abstraction, Python provides a compound structure called a <code>list</code>, which can be constructed by placing expressions within square brackets separated by commas. Such an expression is called a list literal.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [10, 20]</span><br><span class="line">[10, 20]</span><br></pre></td></tr></table></figure>

<p>The elements of a list can be accessed in two ways. The first way is via our familiar method of multiple assignment, which unpacks a list into its elements and binds each element to a different name.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pair = [10, 20]</span><br><span class="line">&gt;&gt;&gt; pair</span><br><span class="line">[10, 20]</span><br><span class="line">&gt;&gt;&gt; x, y = pair</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>A second method for accessing the elements in a list is by the element selection operator, also expressed using square brackets. Unlike a list literal, a square-brackets expression directly following another expression does not evaluate to a <code>list</code> value, but instead selects an element from the value of the preceding expression.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pair[0]</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; pair[1]</span><br><span class="line">20</span><br></pre></td></tr></table></figure>





<h2 id="2-3-Sequences"><a href="#2-3-Sequences" class="headerlink" title="2.3 Sequences"></a>2.3 Sequences</h2><p>A sequence is an ordered collection of values. The sequence is a powerful, fundamental abstraction in computer science. Sequences are not instances of a particular built-in type or abstract data representation, but instead a collection of behaviors that are shared among several different types of data. That is, there are many kinds of sequences, but they all share common behavior. In particular,</p>
<p><strong>Length.</strong> A sequence has a finite length. An empty sequence has length 0.</p>
<p><strong>Element selection.</strong> A sequence has an element corresponding to any non-negative integer index less than its length, starting at 0 for the first element.</p>
<p>Python includes several native data types that are sequences, the most important of which is the <code>list</code>.</p>
<h3 id="2-3-1-Lists"><a href="#2-3-1-Lists" class="headerlink" title="2.3.1  Lists"></a>2.3.1  Lists</h3><p>A <code>list</code> value is a sequence that can have arbitrary length. Lists have a large set of built-in behaviors, along with specific syntax to express those behaviors. We have already seen the list literal, which evaluates to a <code>list</code> instance, as well as an element selection expression that evaluates to a value in the list. The built-in <code>len</code> function returns the length of a sequence. Below, <code>digits</code> is a list with four elements. The element at index 3 is 8.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; digits = [1, 8, 2, 8]</span><br><span class="line">&gt;&gt;&gt; len(digits)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; digits[3]</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>Additionally, lists can be added together and multiplied by integers. <strong>For sequences, addition and multiplication do not add or multiply elements, but instead combine and replicate the sequences themselves.</strong> That is, the <code>add</code> function in the <code>operator</code> module (and the <code>+</code> operator) yields a list that is the concatenation of the added arguments. The <code>mul</code> function in <code>operator</code> (and the <code>*</code> operator) can take a list and an integer <code>k</code> to return the list that consists of <code>k</code> repetitions of the original list.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [2, 7] + digits * 2</span><br><span class="line">[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]</span><br></pre></td></tr></table></figure>

<p>Any values can be included in a list, including another list. Element selection can be applied multiple times in order to select a deeply nested element in a list containing lists.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pairs = [[10, 20], [30, 40]]</span><br><span class="line">&gt;&gt;&gt; pairs[1]</span><br><span class="line">[30, 40]</span><br><span class="line">&gt;&gt;&gt; pairs[1][0]</span><br><span class="line">30</span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-Sequence-Iteration"><a href="#2-3-2-Sequence-Iteration" class="headerlink" title="2.3.2  Sequence Iteration"></a>2.3.2  Sequence Iteration</h3><p>In many cases, we would like to iterate over the elements of a sequence and perform some computation for each element in turn. This pattern is so common that Python has an additional control statement to process sequential data: the <code>for</code> statement.</p>
<p>Consider the problem of counting how many times a value appears in a sequence. We can implement a function to compute this count using a <code>while</code> loop.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count(s, value):</span><br><span class="line">        &quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span><br><span class="line">        total, index = 0, 0</span><br><span class="line">        while index &lt; len(s):</span><br><span class="line">            if s[index] == value:</span><br><span class="line">                total = total + 1</span><br><span class="line">            index = index + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; count(digits, 8)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>The Python <code>for</code> statement can simplify this function body by iterating over the element values directly without introducing the name <code>index</code> at all.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def count(s, value):</span><br><span class="line">        &quot;&quot;&quot;Count the number of occurrences of value in sequence s.&quot;&quot;&quot;</span><br><span class="line">        total = 0</span><br><span class="line">        for elem in s:</span><br><span class="line">            if elem == value:</span><br><span class="line">                total = total + 1</span><br><span class="line">        return total</span><br><span class="line">&gt;&gt;&gt; count(digits, 8)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>A <code>for</code> statement consists of a single clause with the form:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &lt;name&gt; in &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>

<p>A <code>for</code> statement is executed by the following procedure:</p>
<ol>
<li>Evaluate the header <code>&lt;expression&gt;</code>, which must yield an iterable value.</li>
<li>For each element value in that iterable value, in order:<ol>
<li>Bind <code>&lt;name&gt;</code> to that value in the current frame.</li>
<li>Execute the <code>&lt;suite&gt;</code>.</li>
</ol>
</li>
</ol>
<p>This execution procedure refers to <em>iterable values</em>. Lists are a type of sequence, and sequences are iterable values. Their elements are considered in their sequential order. Python includes other iterable types, but we will focus on sequences for now; the general definition of the term “iterable” appears in the section on iterators in Chapter 4.</p>
<p>An important consequence of this evaluation procedure is that <code>&lt;name&gt;</code> will be bound to the last element of the sequence after the <code>for</code> statement is executed. The <code>for</code> loop introduces yet another way in which the environment can be updated by a statement.</p>
<p><strong>Sequence unpacking.</strong> A common pattern in programs is to have a sequence of elements that are themselves sequences, but all of a fixed length. A <code>for</code> statement may include multiple names in its header to “unpack” each element sequence into its respective elements. For example, we may have a list of two-element lists.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]</span><br></pre></td></tr></table></figure>

<p>and wish to find the number of these pairs that have the same first and second element.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; same_count = 0</span><br></pre></td></tr></table></figure>

<p>The following <code>for</code> statement with two names in its header will bind each name <code>x</code> and <code>y</code> to the first and second elements in each pair, respectively.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x, y in pairs:</span><br><span class="line">        if x == y:</span><br><span class="line">            same_count = same_count + 1</span><br><span class="line">&gt;&gt;&gt; same_count</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>This pattern of binding multiple names to multiple values in a fixed-length sequence is called <em>sequence unpacking</em>; it is the same pattern that we see in assignment statements that bind multiple names to multiple values.</p>
<p><strong>Ranges.</strong> A <code>range</code> is another built-in type of sequence in Python, which represents a range of integers. Ranges are created with <code>range</code>, which takes two integer arguments: the first number and one beyond the last number in the desired range.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(1, 10)  # Includes 1, but not 10</span><br><span class="line">range(1, 10)</span><br></pre></td></tr></table></figure>

<p>Calling the <code>list</code> constructor on a range evaluates to a list with the same elements as the range, so that the elements can be easily inspected.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(5, 8))</span><br><span class="line">[5, 6, 7]</span><br></pre></td></tr></table></figure>

<p>If only one argument is given, it is interpreted as one beyond the last value for a range that starts at 0.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(4))</span><br><span class="line">[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Ranges commonly appear as the expression in a <code>for</code> header to specify the number of times that the suite should be executed: A common convention is to use a single underscore character for the name in the <code>for</code> header if the name is unused in the suite:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(3):</span><br><span class="line">        print(&#x27;Go Bears!&#x27;)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure>

<p>This underscore is just another name in the environment as far as the interpreter is concerned, but has a conventional meaning among programmers that indicates the name will not appear in any future expressions.</p>
<h3 id="2-3-3-Sequence-Processing"><a href="#2-3-3-Sequence-Processing" class="headerlink" title="2.3.3  Sequence Processing"></a>2.3.3  Sequence Processing</h3><p>Sequences are such a common form of compound data that whole programs are often organized around this single abstraction. Modular components that have sequences as both inputs and outputs can be mixed and matched to perform data processing. Complex components can be defined by chaining together a pipeline of sequence processing operations, each of which is simple and focused.</p>
<p><strong>List Comprehensions.</strong> Many sequence processing operations can be expressed by evaluating a fixed expression for each element in a sequence and collecting the resulting values in a result sequence. In Python, a list comprehension is an expression that performs such a computation.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; odds = [1, 3, 5, 7, 9]</span><br><span class="line">&gt;&gt;&gt; [x+1 for x in odds]</span><br><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>

<p>The <code>for</code> keyword above is not part of a <code>for</code> statement, but instead part of a list comprehension because it is contained within square brackets. The sub-expression <code>x+1</code> is evaluated with <code>x</code> bound to each element of <code>odds</code> in turn, and the resulting values are collected into a list.</p>
<p>Another common sequence processing operation is to select a subset of values that satisfy some condition. List comprehensions can also express this pattern, for instance selecting all elements of <code>odds</code> that evenly divide <code>25</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in odds if 25 % x == 0]</span><br><span class="line">[1, 5]</span><br></pre></td></tr></table></figure>

<p>The general form of a list comprehension is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;]</span><br></pre></td></tr></table></figure>

<p>To evaluate a list comprehension, Python evaluates the <code>&lt;sequence expression&gt;</code>, which must return an iterable value. Then, for each element in order, the element value is bound to <code>&lt;name&gt;</code>, the filter expression is evaluated, and if it yields a true value, the map expression is evaluated. The values of the map expression are collected into a list.</p>
<p><strong>Aggregation.</strong> A third common pattern in sequence processing is to aggregate all values in a sequence into a single value. The built-in functions <code>sum</code>, <code>min</code>, and <code>max</code> are all examples of aggregation functions.</p>
<p>By combining the patterns of evaluating an expression for each element, selecting a subset of elements, and aggregating elements, we can solve problems using a sequence processing approach.</p>
<p>A perfect number is a positive integer that is equal to the sum of its divisors. The divisors of <code>n</code> are positive integers less than <code>n</code> that divide evenly into <code>n</code>. Listing the divisors of <code>n</code> can be expressed with a list comprehension.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def divisors(n):</span><br><span class="line">        return [1] + [x for x in range(2, n) if n % x == 0]</span><br><span class="line">&gt;&gt;&gt; divisors(4)</span><br><span class="line">[1, 2]</span><br><span class="line">&gt;&gt;&gt; divisors(12)</span><br><span class="line">[1, 2, 3, 4, 6]</span><br></pre></td></tr></table></figure>

<p>Using <code>divisors</code>, we can compute all perfect numbers from 1 to 1000 with another list comprehension. (1 is typically considered to be a perfect number as well, but it does not qualify under our definition of <code>divisors</code>.)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [n for n in range(1, 1000) if sum(divisors(n)) == n]</span><br><span class="line">[6, 28, 496]</span><br></pre></td></tr></table></figure>

<p>We can reuse our definition of <code>divisors</code> to solve another problem, finding the minimum perimeter of a rectangle with integer side lengths, given its area. The area of a rectangle is its height times its width. Therefore, given the area and height, we can compute the width. We can assert that both the width and height evenly divide the area to ensure that the side lengths are integers.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def width(area, height):</span><br><span class="line">        assert area % height == 0</span><br><span class="line">        return area // height</span><br></pre></td></tr></table></figure>

<p>The perimeter of a rectangle is the sum of its side lengths.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def perimeter(width, height):</span><br><span class="line">        return 2 * width + 2 * height</span><br></pre></td></tr></table></figure>

<p>The height of a rectangle with integer side lengths must be a divisor of its area. We can compute the minimum perimeter by considering all heights.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def minimum_perimeter(area):</span><br><span class="line">        heights = divisors(area)</span><br><span class="line">        perimeters = [perimeter(width(area, h), h) for h in heights]</span><br><span class="line">        return min(perimeters)</span><br><span class="line">&gt;&gt;&gt; area = 80</span><br><span class="line">&gt;&gt;&gt; width(area, 5)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; perimeter(16, 5)</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt; perimeter(10, 8)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; minimum_perimeter(area)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; [minimum_perimeter(n) for n in range(1, 10)]</span><br><span class="line">[4, 6, 8, 8, 12, 10, 16, 12, 12]</span><br></pre></td></tr></table></figure>





<h3 id="2-3-4-Sequence-Abstraction"><a href="#2-3-4-Sequence-Abstraction" class="headerlink" title="2.3.4  Sequence Abstraction"></a>2.3.4  Sequence Abstraction</h3><p>We have introduced two native data types that satisfy the sequence abstraction: lists and ranges. Both satisfy the conditions with which we began this section: length and element selection. Python includes two more behaviors of sequence types that extend the sequence abstraction.</p>
<p><strong>Membership.</strong> A value can be tested for membership in a sequence. Python has two operators <code>in</code> and <code>not in</code> that evaluate to <code>True</code> or <code>False</code> depending on whether an element appears in a sequence.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; digits</span><br><span class="line">[1, 8, 2, 8]</span><br><span class="line">&gt;&gt;&gt; 2 in digits</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 1828 not in digits</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>Slicing.</strong> Sequences contain smaller sequences within them. A <em>slice</em> of a sequence is any contiguous span of the original sequence, designated by a pair of integers. As with the <code>range</code> constructor, the first integer indicates the starting index of the slice and the second indicates one beyond the ending index.</p>
<p>In Python, sequence slicing is expressed similarly to element selection, using square brackets. A colon separates the starting and ending indices. Any bound that is omitted is assumed to be an extreme value: 0 for the starting index, and the length of the sequence for the ending index.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; digits[0:2]</span><br><span class="line">[1, 8]</span><br><span class="line">&gt;&gt;&gt; digits[1:]</span><br><span class="line">[8, 2, 8]</span><br></pre></td></tr></table></figure>



<h3 id="2-3-5-Strings"><a href="#2-3-5-Strings" class="headerlink" title="2.3.5  Strings"></a>2.3.5  Strings</h3><p>Text values are perhaps more fundamental to computer science than even numbers. As a case in point, Python programs are written and stored as text. The native data type for text in Python is called a string, and corresponds to the constructor <code>str</code>.</p>
<p>There are many details of how strings are represented, expressed, and manipulated in Python. Strings are another example of a rich abstraction, one that requires a substantial commitment on the part of the programmer to master. This section serves as a condensed introduction to essential string behaviors.</p>
<p>String literals can express arbitrary text, surrounded by either single or double quotation marks.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;I am string!&#x27;</span><br><span class="line">&#x27;I am string!&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;I&#x27;ve got an apostrophe&quot;</span><br><span class="line">&quot;I&#x27;ve got an apostrophe&quot;</span><br><span class="line">&gt;&gt;&gt; &#x27;您好&#x27;</span><br><span class="line">&#x27;您好&#x27;</span><br></pre></td></tr></table></figure>

<p>We have seen strings already in our code, as docstrings, in calls to <code>print</code>, and as error messages in <code>assert</code> statements.</p>
<p>Strings satisfy the two basic conditions of a sequence that we introduced at the beginning of this section: they have a length and they support element selection.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; city = &#x27;Berkeley&#x27;</span><br><span class="line">&gt;&gt;&gt; len(city)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; city[3]</span><br><span class="line">&#x27;k&#x27;</span><br></pre></td></tr></table></figure>

<p>The elements of a string are themselves strings that have only a single character. A character is any single letter of the alphabet, punctuation mark, or other symbol. Unlike many other programming languages, Python does not have a separate character type; any text is a string, and strings that represent single characters have a length of 1.</p>
<p>Like lists, strings can also be combined via addition and multiplication.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Berkeley&#x27; + &#x27;, CA&#x27;</span><br><span class="line">&#x27;Berkeley, CA&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;Shabu &#x27; * 2</span><br><span class="line">&#x27;Shabu Shabu &#x27;</span><br></pre></td></tr></table></figure>

<p><strong>Membership.</strong> The behavior of strings diverges from other sequence types in Python. The string abstraction does not conform to the full sequence abstraction that we described for lists and ranges. In particular, the membership operator <code>in</code> applies to strings, but has an entirely different behavior than when it is applied to sequences. It matches substrings rather than elements.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;here&#x27; in &quot;Where&#x27;s Waldo?&quot;</span><br><span class="line">True</span><br></pre></td></tr></table></figure>



<h2 id="2-4-Mutable-Data"><a href="#2-4-Mutable-Data" class="headerlink" title="2.4  Mutable Data"></a>2.4  Mutable Data</h2><p>We have seen how abstraction is vital in helping us to cope with the complexity of large systems. Effective programming also requires organizational principles that can guide us in formulating the overall design of a program. In particular, we need strategies to help us structure large systems to be modular, meaning that they divide naturally into coherent parts that can be separately developed and maintained.</p>
<p>One powerful technique for creating modular programs is to incorporate data that may change state over time. In this way, a single data object can represent something that evolves independently of the rest of the program. The behavior of a changing object may be influenced by its history, just like an entity in the world. Adding state to data is a central ingredient of a paradigm called object-oriented programming.</p>
<h2 id="2-5-Object-Oriented-Programming"><a href="#2-5-Object-Oriented-Programming" class="headerlink" title="2.5  Object-Oriented Programming"></a>2.5  Object-Oriented Programming</h2><p>Object-oriented programming (OOP) is a method for organizing programs that brings together many of the ideas introduced in this chapter. Like the functions in data abstraction, classes create abstraction barriers between the use and implementation of data. Like dispatch dictionaries, objects respond to behavioral requests. Like mutable data structures, objects have local state that is not directly accessible from the global environment. The Python object system provides convenient syntax to promote the use of these techniques for organizing programs. Much of this syntax is shared among other object-oriented programming languages.</p>
<p>The object system offers more than just convenience. It enables a new metaphor for designing programs in which several independent agents interact within the computer. Each object bundles together local state and behavior in a way that abstracts the complexity of both. Objects communicate with each other, and useful results are computed as a consequence of their interaction. Not only do objects pass messages, they also share behavior among other objects of the same type and inherit characteristics from related types.</p>
<p>The paradigm of object-oriented programming has its own vocabulary that supports the object metaphor. We have seen that an object is a data value that has methods and attributes, accessible via dot notation. Every object also has a type, called its <em>class</em>. To create new types of data, we <strong>implement new classes.</strong></p>
<h3 id="2-5-1-Objects-and-Classes"><a href="#2-5-1-Objects-and-Classes" class="headerlink" title="2.5.1  Objects and Classes"></a>2.5.1  Objects and Classes</h3><p>A class serves as a template for all objects whose type is that class. Every object is an instance of some particular class. The objects we have used so far all have built-in classes, but new user-defined classes can be created as well. A class definition specifies the attributes and methods shared among objects of that class. We will introduce the class statement by revisiting the example of a bank account.</p>
<p>When introducing local state, we saw that bank accounts are naturally modeled as mutable values that have a <code>balance</code>. A bank account object should have a <code>withdraw</code> method that updates the account balance and returns the requested amount, if it is available. To complete the abstraction: a bank account should be able to return its current <code>balance</code>, return the name of the account <code>holder</code>, and an amount for <code>deposit</code>.</p>
<p>An <code>Account</code> class allows us to create multiple instances of bank accounts. The act of creating a new object instance is known as <em>instantiating</em> the class. The syntax in Python for instantiating a class is identical to the syntax of calling a function. In this case, we call <code>Account</code> with the argument <code>&#39;Kirk&#39;</code>, the account holder’s name.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Account(&#x27;Kirk&#x27;)</span><br></pre></td></tr></table></figure>

<p>An <em>attribute</em> of an object is a name-value pair associated with the object, which is accessible via dot notation. The attributes specific to a particular object, as opposed to all objects of a class, are called <em>instance attributes</em>. Each <code>Account</code> has its own balance and account holder name, which are examples of instance attributes. In the broader programming community, instance attributes may also be called <em>fields</em>, <em>properties</em>, or <em>instance variables</em>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.holder</span><br><span class="line">&#x27;Kirk&#x27;</span><br><span class="line">&gt;&gt;&gt; a.balance</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>Functions that operate on the object or perform object-specific computations are called methods. The return values and side effects of a method can depend upon and change other attributes of the object. For example, <code>deposit</code> is a method of our <code>Account</code> object <code>a</code>. It takes one argument, the amount to deposit, changes the <code>balance</code> attribute of the object, and returns the resulting balance.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.deposit(15)</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>We say that methods are <em>invoked</em> on a particular object. As a result of invoking the <code>withdraw</code> method, either the withdrawal is approved and the amount is deducted, or the request is declined and the method returns an error message.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.withdraw(10)  # The withdraw method returns the balance after withdrawal</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; a.balance       # The balance attribute has changed</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; a.withdraw(10)</span><br><span class="line">&#x27;Insufficient funds&#x27;</span><br></pre></td></tr></table></figure>

<p>As illustrated above, the behavior of a method can depend upon the changing attributes of the object. Two calls to <code>withdraw</code> with the same argument return different results.</p>
<h3 id="2-5-2-Defining-Classes"><a href="#2-5-2-Defining-Classes" class="headerlink" title="2.5.2  Defining Classes"></a>2.5.2  Defining Classes</h3><p>User-defined classes are created by <code>class</code> statements, which consist of a single clause. A class statement defines the class name, then includes a suite of statements to define the attributes of the class:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class &lt;name&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></table></figure>

<p>When a class statement is executed, a new class is created and bound to <code>&lt;name&gt;</code> in the first frame of the current environment. The suite is then executed. Any names bound within the <code>&lt;suite&gt;</code> of a <code>class</code> statement, through <code>def</code> or assignment statements, create or modify attributes of the class.</p>
<p>Classes are typically organized around manipulating instance attributes, which are the name-value pairs associated with each instance of that class. The class specifies the instance attributes of its objects by defining a method for initializing new objects. For example, part of initializing an object of the <code>Account</code> class is to assign it a starting balance of 0.</p>
<p>The <code>&lt;suite&gt;</code> of a <code>class</code> statement contains <code>def</code> statements that define new methods for objects of that class. The method that initializes objects has a special name in Python, <code>__init__</code> (two underscores on each side of the word “init”), and is called the <em>constructor</em> for the class.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self.balance = 0</span><br><span class="line">            self.holder = account_holder</span><br></pre></td></tr></table></figure>

<p>The <code>__init__</code> method for <code>Account</code> has two formal parameters. The first one, <code>self</code>, is bound to the newly created <code>Account</code> object. The second parameter, <code>account_holder</code>, is bound to the argument passed to the class when it is called to be instantiated.</p>
<p>The constructor binds the instance attribute name <code>balance</code> to 0. It also binds the attribute name <code>holder</code> to the value of the name <code>account_holder</code>. The formal parameter <code>account_holder</code> is a local name in the <code>__init__</code> method. On the other hand, the name <code>holder</code> that is bound via the final assignment statement persists, because it is stored as an attribute of <code>self</code> using dot notation.</p>
<p>Having defined the <code>Account</code> class, we can instantiate it.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Account(&#x27;Kirk&#x27;)</span><br></pre></td></tr></table></figure>

<p>This “call” to the <code>Account</code> class creates a new object that is an instance of <code>Account</code>, then calls the constructor function <code>__init__</code> with two arguments: the newly created object and the string <code>&#39;Kirk&#39;</code>. By convention, we use the parameter name <code>self</code> for the first argument of a constructor, because it is bound to the object being instantiated. This convention is adopted in virtually all Python code.</p>
<p>Now, we can access the object’s <code>balance</code> and <code>holder</code> using dot notation.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.balance</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; a.holder</span><br><span class="line">&#x27;Kirk&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>Identity.</strong> Each new account instance has its own balance attribute, the value of which is independent of other objects of the same class.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = Account(&#x27;Spock&#x27;)</span><br><span class="line">&gt;&gt;&gt; b.balance = 200</span><br><span class="line">&gt;&gt;&gt; [acc.balance for acc in (a, b)]</span><br><span class="line">[0, 200]</span><br></pre></td></tr></table></figure>

<p>To enforce this separation, every object that is an instance of a user-defined class has a unique identity. Object identity is compared using the <code>is</code> and <code>is not</code> operators.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a is a</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is not b</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>Despite being constructed from identical calls, the objects bound to <code>a</code> and <code>b</code> are not the same. As usual, binding an object to a new name using assignment does not create a new object.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = a</span><br><span class="line">&gt;&gt;&gt; c is a</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>New objects that have user-defined classes are only created when a class (such as <code>Account</code>) is instantiated with call expression syntax.</p>
<p><strong>Methods.</strong> Object methods are also defined by a <code>def</code> statement in the suite of a <code>class</code> statement. Below, <code>deposit</code> and <code>withdraw</code> are both defined as methods on objects of the <code>Account</code> class.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">        def __init__(self, account_holder):</span><br><span class="line">            self.balance = 0</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">        def deposit(self, amount):</span><br><span class="line">            self.balance = self.balance + amount</span><br><span class="line">            return self.balance</span><br><span class="line">        def withdraw(self, amount):</span><br><span class="line">            if amount &gt; self.balance:</span><br><span class="line">                return &#x27;Insufficient funds&#x27;</span><br><span class="line">            self.balance = self.balance - amount</span><br><span class="line">            return self.balance</span><br></pre></td></tr></table></figure>

<p>While method definitions do not differ from function definitions in how they are declared, method definitions do have a different effect when executed. The function value that is created by a <code>def</code> statement within a <code>class</code> statement is bound to the declared name, but bound locally within the class as an attribute. That value is invoked as a method using dot notation from an instance of the class.</p>
<p>Each method definition again includes a special first parameter <code>self</code>, which is bound to the object on which the method is invoked. For example, let us say that <code>deposit</code> is invoked on a particular <code>Account</code> object and passed a single argument value: the amount deposited. The object itself is bound to <code>self</code>, while the argument is bound to <code>amount</code>. All invoked methods have access to the object via the <code>self</code> parameter, and so they can all access and manipulate the object’s state.</p>
<p>To invoke these methods, we again use dot notation, as illustrated below.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; spock_account = Account(&#x27;Spock&#x27;)</span><br><span class="line">&gt;&gt;&gt; spock_account.deposit(100)</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; spock_account.withdraw(90)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; spock_account.withdraw(90)</span><br><span class="line">&#x27;Insufficient funds&#x27;</span><br><span class="line">&gt;&gt;&gt; spock_account.holder</span><br><span class="line">&#x27;Spock&#x27;</span><br></pre></td></tr></table></figure>

<p>When a method is invoked via dot notation, the object itself (bound to <code>spock_account</code>, in this case) plays a dual role. First, it determines what the name <code>withdraw</code> means; <code>withdraw</code> is not a name in the environment, but instead a name that is local to the <code>Account</code> class. Second, it is bound to the first parameter <code>self</code> when the <code>withdraw</code> method is invoked.</p>
<h1 id="Chapter-3-Interpreting-Computer-Programs"><a href="#Chapter-3-Interpreting-Computer-Programs" class="headerlink" title="Chapter 3: Interpreting Computer Programs"></a>Chapter 3: Interpreting Computer Programs</h1><h2 id="3-1-Introduction"><a href="#3-1-Introduction" class="headerlink" title="3.1  Introduction"></a>3.1  Introduction</h2><p>Chapters 1 and 2 describe the close connection between two fundamental elements of programming: functions and data. We saw how functions can be manipulated as data using higher-order functions. We also saw how data can be endowed with behavior using message passing and an object system. We have also studied techniques for organizing large programs, such as functional abstraction, data abstraction, class inheritance, and generic functions. These core concepts constitute a strong foundation upon which to build modular, maintainable, and extensible programs.</p>
<p>This chapter focuses on the third fundamental element of programming: programs themselves. A Python program is just a collection of text. Only through the process of interpretation do we perform any meaningful computation based on that text. A programming language like Python is useful because we can define an <em>interpreter</em>, a program that carries out Python’s evaluation and execution procedures. It is no exaggeration to regard this as the most fundamental idea in programming, that an interpreter, which determines the meaning of expressions in a programming language, is just another program.</p>
<p>To appreciate this point is to change our images of ourselves as programmers. We come to see ourselves as designers of languages, rather than only users of languages designed by others.</p>
<h3 id="3-1-1-Programming-Languages"><a href="#3-1-1-Programming-Languages" class="headerlink" title="3.1.1  Programming Languages"></a>3.1.1  Programming Languages</h3><p>Programming languages vary widely in their syntactic structures, features, and domain of application. Among general purpose programming languages, the constructs of function definition and function application are pervasive. On the other hand, powerful languages exist that do not include an object system, higher-order functions, assignment, or even control constructs such as <code>while</code> and <code>for</code> statements. As an example of a powerful language with a minimal set of features, we will introduce the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> programming language. The subset of Scheme introduced in this text does not allow mutable values at all.</p>
<p>In this chapter, we study the design of interpreters and the computational processes that they create when executing programs. The prospect of designing an interpreter for a general programming language may seem daunting. After all, interpreters are programs that can carry out any possible computation, depending on their input. However, many interpreters have an elegant common structure: two mutually recursive functions. The first evaluates expressions in environments; the second applies functions to arguments.</p>
<p>These functions are recursive in that they are defined in terms of each other: applying a function requires evaluating the expressions in its body, while evaluating an expression may involve applying one or more functions.</p>
<h2 id="3-3-Exceptions"><a href="#3-3-Exceptions" class="headerlink" title="3.3  Exceptions"></a>3.3  Exceptions</h2><p>Programmers must be always mindful of possible errors that may arise in their programs. Examples abound: a function may not receive arguments that it is designed to accept, a necessary resource may be missing, or a connection across a network may be lost. When designing a program, one must anticipate the exceptional circumstances that may arise and take appropriate measures to handle them.</p>
<p>There is no single correct approach to handling errors in a program. Programs designed to provide some persistent service like a web server should be robust to errors, logging them for later consideration but continuing to service new requests as long as possible. On the other hand, the Python interpreter handles errors by terminating immediately and printing an error message, so that programmers can address issues as soon as they arise. In any case, programmers must make conscious choices about how their programs should react to exceptional conditions.</p>
<p><em>Exceptions</em>, the topic of this section, provides a general mechanism for adding error-handling logic to programs. <em>Raising an exception</em> is a technique for interrupting the normal flow of execution in a program, signaling that some exceptional circumstance has arisen, and returning directly to an enclosing part of the program that was designated to react to that circumstance. The Python interpreter raises an exception each time it detects an error in an expression or statement. Users can also raise exceptions with <code>raise</code> and <code>assert</code> statements.</p>
<p><strong>Raising exceptions.</strong> An exception is a object instance with a class that inherits, either directly or indirectly, from the <code>BaseException</code> class. The <code>assert</code> statement introduced in Chapter 1 raises an exception with the class <code>AssertionError</code>. In general, any exception instance can be raised with the <code>raise</code> statement. The general form of raise statements are described in the <a target="_blank" rel="noopener" href="http://docs.python.org/py3k/reference/simple_stmts.html#raise">Python docs</a>. The most common use of <code>raise</code> constructs an exception instance and raises it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> Exception(<span class="string">&#x27;An error occurred&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">Exception: an error occurred</span><br></pre></td></tr></table></figure>

<p>When an exception is raised, no further statements in the current block of code are executed. Unless the exception is <em>handled</em> (described below), the interpreter will return directly to the interactive read-eval-print loop, or terminate entirely if Python was started with a file argument. In addition, the interpreter will print a <em>stack backtrace</em>, which is a structured block of text that describes the nested set of active function calls in the branch of execution in which the exception was raised. In the example above, the file name <code>&lt;stdin&gt;</code> indicates that the exception was raised by the user in an interactive session, rather than from code in a file.</p>
<p><strong>Handling exceptions.</strong> An exception can be handled by an enclosing <code>try</code> statement. A <code>try</code> statement consists of multiple clauses; the first begins with <code>try</code> and the rest begin with <code>except</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;<span class="keyword">try</span> suite&gt;</span><br><span class="line"><span class="keyword">except</span> &lt;exception <span class="keyword">class</span>&gt; <span class="keyword">as</span> &lt;name&gt;:</span><br><span class="line">    &lt;<span class="keyword">except</span> suite&gt;</span><br></pre></td></tr></table></figure>





<h2 id="3-4-Interpreters-for-Languages-with-Combination"><a href="#3-4-Interpreters-for-Languages-with-Combination" class="headerlink" title="3.4  Interpreters for Languages with Combination"></a>3.4  Interpreters for Languages with Combination</h2><h1 id="Chapter-4-Data-Processing"><a href="#Chapter-4-Data-Processing" class="headerlink" title="Chapter 4: Data Processing"></a>Chapter 4: Data Processing</h1><h2 id="4-1-Introduction"><a href="#4-1-Introduction" class="headerlink" title="4.1  Introduction"></a>4.1  Introduction</h2><p>Modern computers can process vast amounts of data representing many aspects of the world. From these big data sets, we can learn about human behavior in unprecedented ways: how language is used, what photos are taken, what topics are discussed, and how people engage with their surroundings. To process large data sets efficiently, programs are organized into pipelines of manipulations on sequential streams of data. In this chapter, we consider a suite of techniques process and manipulate sequential data streams efficiently.</p>
<p>In Chapter 2, we introduced a sequence interface, implemented in Python by built-in data types such as <code>list</code> and <code>range</code>. In this chapter, we extend the concept of sequential data to include collections that have unbounded or even infinite size. Two mathematical examples of infinite sequences are the positive integers and the Fibonacci numbers. Sequential data sets of unbounded length also appear in other computational domains. For instance, the sequence of telephone calls sent through a cell tower, the sequence of mouse movements made by a computer user, and the sequence of acceleration measurements from sensors on an aircraft all continue to grow as the world evolves.</p>
<h2 id="4-2-Implicit-Sequences"><a href="#4-2-Implicit-Sequences" class="headerlink" title="4.2  Implicit Sequences"></a>4.2  Implicit Sequences</h2><p>A sequence can be represented without each element being stored explicitly in the memory of the computer. That is, we can construct an object that provides access to all of the elements of some sequential dataset without computing the value of each element in advance. Instead, we compute elements on demand.</p>
<p>An example of this idea arises in the <code>range</code> container type introduced in Chapter 2. A <code>range</code> represents a consecutive, bounded sequence of integers. However, it is not the case that each element of that sequence is represented explicitly in memory. </p>
<h2 id="4-3-Declarative-Programming"><a href="#4-3-Declarative-Programming" class="headerlink" title="4.3  Declarative Programming"></a>4.3  Declarative Programming</h2><h2 id="4-4-Logic-Programming"><a href="#4-4-Logic-Programming" class="headerlink" title="4.4  Logic Programming"></a>4.4  Logic Programming</h2>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/12/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/12/22/61A_Lab/" rel="next" title="CS61A Lab">
      CS61A Lab <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GOOD-web"><span class="nav-number">1.</span> <span class="nav-text">GOOD web</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vocab"><span class="nav-number">2.</span> <span class="nav-text">Vocab</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C1-Building-Abstractions-with-Functions"><span class="nav-number">3.</span> <span class="nav-text">C1 Building Abstractions with Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1"><span class="nav-number">3.1.</span> <span class="nav-text">1.1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-First-Example"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1.4  First Example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Elements-of-Programming"><span class="nav-number">3.2.</span> <span class="nav-text">1.2 Elements of Programming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Defining-new-function"><span class="nav-number">3.3.</span> <span class="nav-text">1.3 Defining new function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">1.3.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-2"><span class="nav-number">3.4.</span> <span class="nav-text">1.3.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4"><span class="nav-number">3.5.</span> <span class="nav-text">1.4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-Control"><span class="nav-number">3.6.</span> <span class="nav-text">1.5 Control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-Statements"><span class="nav-number">3.6.1.</span> <span class="nav-text">1.5.1 Statements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-4"><span class="nav-number">3.6.2.</span> <span class="nav-text">1.5.4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-5-Iteration"><span class="nav-number">3.6.3.</span> <span class="nav-text">1.5.5 Iteration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-6-Testing"><span class="nav-number">3.6.4.</span> <span class="nav-text">1.5.6 Testing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-Higher-Order-Functions"><span class="nav-number">3.7.</span> <span class="nav-text">1.6 Higher-Order Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-Functions-as-Arguments"><span class="nav-number">3.7.1.</span> <span class="nav-text">1.6.1  Functions as Arguments</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-Building-Abstractions-with-Data"><span class="nav-number">4.</span> <span class="nav-text">Chapter 2: Building Abstractions with Data</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Introduction"><span class="nav-number">4.1.</span> <span class="nav-text">2.1  Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Native-Data-Types"><span class="nav-number">4.1.1.</span> <span class="nav-text">2.1.1  Native Data Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Native-Data-Types-1"><span class="nav-number">4.1.2.</span> <span class="nav-text">2.1.1  Native Data Types</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Data-Abstraction"><span class="nav-number">4.2.</span> <span class="nav-text">2.2  Data Abstraction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-Example-Rational-Numbers"><span class="nav-number">4.2.1.</span> <span class="nav-text">2.2.1  Example: Rational Numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-Pairs"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.2.2  Pairs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Sequences"><span class="nav-number">4.3.</span> <span class="nav-text">2.3 Sequences</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-Lists"><span class="nav-number">4.3.1.</span> <span class="nav-text">2.3.1  Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-Sequence-Iteration"><span class="nav-number">4.3.2.</span> <span class="nav-text">2.3.2  Sequence Iteration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-Sequence-Processing"><span class="nav-number">4.3.3.</span> <span class="nav-text">2.3.3  Sequence Processing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-Sequence-Abstraction"><span class="nav-number">4.3.4.</span> <span class="nav-text">2.3.4  Sequence Abstraction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-Strings"><span class="nav-number">4.3.5.</span> <span class="nav-text">2.3.5  Strings</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Mutable-Data"><span class="nav-number">4.4.</span> <span class="nav-text">2.4  Mutable Data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Object-Oriented-Programming"><span class="nav-number">4.5.</span> <span class="nav-text">2.5  Object-Oriented Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-Objects-and-Classes"><span class="nav-number">4.5.1.</span> <span class="nav-text">2.5.1  Objects and Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-Defining-Classes"><span class="nav-number">4.5.2.</span> <span class="nav-text">2.5.2  Defining Classes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-3-Interpreting-Computer-Programs"><span class="nav-number">5.</span> <span class="nav-text">Chapter 3: Interpreting Computer Programs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Introduction"><span class="nav-number">5.1.</span> <span class="nav-text">3.1  Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-Programming-Languages"><span class="nav-number">5.1.1.</span> <span class="nav-text">3.1.1  Programming Languages</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Exceptions"><span class="nav-number">5.2.</span> <span class="nav-text">3.3  Exceptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Interpreters-for-Languages-with-Combination"><span class="nav-number">5.3.</span> <span class="nav-text">3.4  Interpreters for Languages with Combination</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-4-Data-Processing"><span class="nav-number">6.</span> <span class="nav-text">Chapter 4: Data Processing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Introduction"><span class="nav-number">6.1.</span> <span class="nav-text">4.1  Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Implicit-Sequences"><span class="nav-number">6.2.</span> <span class="nav-text">4.2  Implicit Sequences</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Declarative-Programming"><span class="nav-number">6.3.</span> <span class="nav-text">4.3  Declarative Programming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-Logic-Programming"><span class="nav-number">6.4.</span> <span class="nav-text">4.4  Logic Programming</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
